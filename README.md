# PumLang

Это руководство содержит информацию о проекте PumLang - интерпретаторе языка программирования PumLang. Это был учебный проект, поэтому в коде я постараюсь довить некоторое количество комментариев и максимально подробно описать что и как работает.

# Описание

PumLang - язык программирования, который реализует следующие требования:

- Переменные: Язык поддерживает переменные, которым можно присвоить значения, а затем использовать эти значения в программе.
- Строгая типизация: Переменные в PumLang имеют строгую типизацию. При объявлении переменной программист должен указать тип данных, который она будет хранить.
- Типы данных: Язык поддерживает целые числа, вещественные числа и булевы значения (истина и ложь).
- Условный оператор: Поддерживается оператор условного перехода, который позволяет выполнить блок кода при соблюдении определенного условия.
- Оператор цикла: Поддерживается оператор цикла, который позволяет выполнять блок кода циклично, пока выполняется некоторое условие.
- Обработка ошибок: В случае синтаксической ошибки в программе, интерпретатор должен сообщить о ней, указав строку, в которой она произошла, и кратко описав ее суть.
- Ввод значения переменной: Язык позволяет пользователю вводить значения переменных, которые считываются с клавиатуры с помощью функции `input()` в Python.
- Вывод значения выражения на экран: Язык предоставляет функцию для отображения значений выражений на экране.

# Архитектура

Архитектура интерпретатора PumLang следует следующим основным этапам:

1. Лексический анализ: На этом этапе исходный код программы разбивается на лексемы, такие как операторы, ключевые слова, идентификаторы и т.д. Лексический анализатор обрабатывает строку и создает список лексем.
2. Синтаксический анализ: Список лексем анализируется для проверки синтаксической корректности программы. Используется метод рекурсивного спуска для построения синтаксического дерева или другой формы внутреннего представления программы.
3. Исполнение программы: Интерпретатор выполняет программу, используя внутреннее представление. Это включает работу со стеком для хранения значений и выполнение операций в соответствии с логикой языка PumLang.

# Грамматика языка Pumlang

```python
P  -> B&
B  -> {S [;S]^}
S  -> [int | bool | float] I [,I]^ | [int | bool | float] I := E| I := E | if (E) B [else B] | while (E) B | input(I) | print(E)
E  -> E1 [[> | < | = | !=] E1]
E1 -> T [[+ | - | or] T]^
T  -> F [[* | / | % | // | and] F]^
F  -> I | N | L | not F | (E)
L  -> true | false
I  -> C[C]^
N  -> R[.R]
R  -> D[D]^
C  -> a | b | ... | z
D  -> 0 | 1 | ... | 9

```


Попробуем разобраться в написанном. Данная грамматика содержит два типа сущностей: терминалы, например int, bool, a и т.д. и нетерминалы, обозначенные большими буквами. Под каждым нетерминальным символом скрывается правило его вывода. Названия нетерминальных символов в этой грамматике выбраны не случайно:
Вертикальная черта | означает выбор одного из вариантов, [] означают, что все, что находится внутри скобок, опционально, т.е. может отсутствовать, запись []^ означает, что написанное в скобках может повторяться несколько раз (возможно 0).
Рассмотрим некоторые правила чуть более подробно.


Распишем каждый пункт грамматики языка:

1. P (Programm) -> B&
   - Программа состоит из блока инструкций B, за которым следует символ "&".

2. B (Block) -> {S [;S]^}
   - Блок инструкций заключен в фигурные скобки "{}".
   - Блок содержит одну или несколько инструкций S, разделенных символом ";".
   - Инструкции могут повторяться ноль или более раз.

3. S (Statement) -> [int | bool | float] I [,I]^ | [int | bool | float] I := E| I := E | if (E) B [else B] | while (E) B | input(I) | print(E)
   - Инструкция может быть одной из следующих:
     - Объявление переменных типа "int", "bool" или "float", за которым следует идентификатор I. Может быть одно или несколько объявлений, разделенных запятой.
     - Присваивание значения выражения E переменной с именем I.
     - Объявление переменной с присваиванием значения и типа данных. int hello := 5. 
     - Условный оператор "if", который проверяет выражение E. За ним следует блок инструкций B. Может быть указан также блок инструкций для случая "else".
     - Цикл "while", который выполняется пока условие выражения E истинно. За ним следует блок инструкций B.
     - Инструкция "input", которая считывает значение с консоли и присваивает его переменной с именем I.
     - Инструкция "print", которая выводит значение выражения E на экран.

4. E (Expression) -> E1 [[> | < | == | != >= <=] E1]
   - Выражение может быть сравнением двух выражений E1, используя операторы сравнения ">" (больше), "<" (меньше), ">=" (больше либо равно), "<=" (меньше либо равно), "=" (равно) или "!=" (не равно).

5. E1 (Expression1) -> T [[+ | - | or] T]^
   - Выражение может содержать одно или несколько слагаемых T, которые могут быть сложены (+), вычтены (-) или объединены логическим оператором "or".

6. T (Term) -> F [[* | / | % | // | and] F]^
   - Выражение может содержать один или несколько множителей F, которые могут быть умножены (*), поделены (/), взяты остаток от деления (%), целочисленно поделены (//) или объединены логическим оператором "and".

7. F (Factor) -> I | N | L | not F | (E)
   - Выражение может быть идентификатором I, числом N, логическим значением L, логической операцией "not" от другого выражения F или выражением в скобках (E).

8. L (Boolean literal) -> true | false
   - Логическое значение может быть либо "true" (истина), либо "false" (ложь).

9. I (Identifier) -> C[C]^
   - Идентификатор начинается с символа C, за которым может следовать ноль или несколько символов C.

10. N (Number) -> R[.R]
    - Число состоит из целой части R, за которой может следовать десятичная часть, отделенная символом ".".

11. R (Digit) -> D[D]^
    - Число или целая часть числа состоит из одной или нескольких цифр D.

12. C (Letter) -> a | b | ... | z
    - Символы идентификаторов могут быть маленькими латинскими буквами от "a" до "z".

13. D (Digit) -> 0 | 1 | ... | 9
    - Цифры представлены символами от "0" до "9".


# Интерпретация

При написании кода не использовались какие-либо специальные библиотеки, кроме math и sys, да и то для того чтобы запускать все через командную строку.
Допустим мы хотим написать программу которая выводит факториал числа на языке Pumlang. Зная грамматику языка мы набросали вот такой код.

```python
{
    int n, s;
    input(n);
    s := 1;
    while (n > 1) {
        s := s * n;
        n := n - 1
    };
    print(s);
}
```


# Запуск своего кода

Изначально планируется что код написанный на языке Pumlang будет запускаться через командную строку. Файл в котором содержится программа написанная на языке Pumlang называется main.plg. Основной файл в проекте на который мы и будем ссылаться в командной строке называется pumlang.py. 

```bash

directory/Pumlang/python pumlang.py main.plg
```

# Лексический анализ. 

Этап лексического анализа является одним из первых шагов в обработке и анализе исходного кода в компьютерных программах. Он представляет собой процесс разбора исходного кода на последовательность лексем, или токенов, которые являются минимальными смысловыми единицами в языке программирования. Цель лексического анализа состоит в том, чтобы разбить исходный код на более простые элементы, которые могут быть легче обработаны и проанализированы на более высоких уровнях компиляции или интерпретации программы. Этот этап является важной частью процесса разработки программного обеспечения и основой для дальнейшего анализа и исполнения кода. Вот общая последовательность шагов, которые обычно включаются в этап лексического анализа:


### 1. Токенизация
Исходный код разбивается на отдельные символы и последовательности символов, называемые токенами. Токены могут представлять собой ключевые слова, идентификаторы переменных, операторы, числа, строки и другие элементы языка программирования. Пробелы и комментарии обычно игнорируются.

```bash
[ "{", "\n", " ", "int", " ", "n", ",", " ", "s", ";", "\n", " ", "input", "(", " ", "n", ")", ";", "\n", " ", "s", " ", ":=", " ", "1", ";",  "\n", " ", "while", " ", "(", " ", "n", " ", ">", " ", "0", " ", ")", " ", "{", "\n", " ", "s", " ", ":=", " ", "s", " ", "*", " ", "n", ";", "\n", " ", "n", " ", ":=", " ", "n", " ", "-", " ", "1", ";", "\n", " ", "}", " ", ";", "\n", " ", "print", "(", " ", "s", " ", ")", ";" ,"\n",  " ", "}", "

```

### 2. Удаление незначащих символов
Лексический анализатор удаляет незначащие символы, такие как пробелы, табуляции и переводы строк, которые не влияют на смысл программы.

```bash
[{, int, n, ',', s, ;, input, (, n, ), ;, s, :=, 1, ;, while, (, n, >, 0, ), {, s, :=, s, *, n, ;, n, :=, n, -, 1, ;, }, ;, print, (, s, ), ;, }]


```

### 3. Классификация токенов
Каждый токен классифицируется в соответствии с его типом. Например, ключевые слова, операторы и идентификаторы могут быть классифицированы по разным категориям.

- `{`, `}`: `LexBraceOpen`, `LexBraceClose`
- `(`, `)`: `LexBktOpen`, `LexBktClose`
- `,`: `LexComma`
- `;`: `LexSemicolon`
- `&`: `LexEnd`
- `int`, `float`, `bool`: `LexType`
- Идентификаторы (например, `n`, `s`): `LexId`
- Целочисленные константы (например, `1`): `LexInt`
- Вещественные константы (нет в данном списке токенов)
- Булевые константы (нет в данном списке токенов)
- `:=`: `LexAssign`
- `input`: `LexInput`
- `print`: `LexPrint`
- `if`: `LexIf`
- `else`: `LexElse`
- `while`: `LexWhile`
- `and`: `LexAnd`
- `or`: `LexOr`
- `not`: `LexNot`
- Бинарные операции (нет в данном списке токенов)

### 4. Обработка ошибок
Лексический анализатор может обнаруживать и обрабатывать ошибки в коде, такие как неверные символы, недопустимые комбинации токенов и другие нарушения синтаксиса языка.

```python
if tokens.count('{') != tokens.count('}') or tokens.count('(') != tokens.count(')'):
    print('Program must have an equal number of opening and closing brackets of all types')
    exit(-1)
elif tokens[0] == '{' and tokens[len(tokens) - 1] == '}':
    return tokens
else:
    print('Program must be in curly brackets: {your code}')
    exit(-1)

```

В этом фрагменте кода мы удостовериваемся, что количество открывающихся и закрывающихся скобочек всех видов совпадает и сама программа находится внутри скобок {}. В результате лексического анализа получается последовательность токенов или лексем, которая передается на следующий этап обработки, такой как синтаксический анализ.

```python
[{, int, n, ',', s, ;, input, (, n, ), ;, s, :=, 1, ;, while, (, n, >, 0, ), {, s, :=, s, *, n, ;, n, :=, n, -, 1, ;, }, ;, print, (, s, ), ;, }]

```


# Cинтаксический анализ 

Синтаксический анализ кода — это процесс анализа и разбора программного кода для определения его структуры и соответствия правилам синтаксиса конкретного языка программирования. Синтаксический анализатор (также известный как парсер) использует грамматические правила, заданные для языка, чтобы определить, правильно ли написан код и какие операции выполняются в коде.
В нашем случае для парсинга кода мы используем метод рекурсивного спуска, оснванный на нашей грамматике. То есть программа будет переходить между состояниями пропуская через себя код, и в случае несоотвествия выдавать ошибку. 

Здесь реализован простой переход между состояниями при начале программы.

```python
   def P(self):
       self.state = "B"
       self.B()
       return
```

А здесь реализован переход из состояния B в состояние S. Заодно мы считаем количество скобок, чтобы поймать ошибку до оновного парсинга, что ускорит работу и без того быстрой программы. Также проверяется наличие ";" после каждой строчки.

```python
   def B(self):
       self.current = self.get_next_elem()
       self.match('{')
       self.current = self.get_next_elem()
       self.state = "S"
       self.S()
       self.state = 'B'
       if self.current != ';' and self.previous not in ['{', '}']:
           self.error(
               f"Expected ; but got {'nothing' if self.current in ['{', '}', '&', ';'] else self.current}")
       while True:
           self.current = self.get_next_elem()
           if self.current == '}':
               self.current = self.get_next_elem()
               if self.current == '&':
                   return
               else:
                   return
           self.state = 'S'
           self.S()
           if self.current == '}' or '{':
               return
           elif self.current == ';':
               continue
           else:
               self.error(
                   f"Expected ; but got {'nothing' if self.current in ['{', '}', '&', ';'] else self.current}")

```
Так пройдя парсером по всему коду и не получив ошибку мы можем переходить к следующему этапу.

# Исполнение программы

Исполнение программы будет разделено на два этапа. 

### 1. Перевод в постфиксную запись

Перевод в польскую запись осуществляется в файле Polish_reversed_notation. Который запускается из файла pumlang.py. Для перевода используется обычный алгоритм для перевода в польскую запись, про него можно почитать здесь https://habr.com/ru/articles/100869/ но также в алгоритм был модифицирован для таких операторов как int, while и тд. 
По итогу после перевода в постфиксную запись (она же польская) мы получаем вот такой список элементов, уже готовый к исполнению.
 
 ```python
 
 [n, s, int, n, input, 1, s, :=, 1, n, >, 25, while, s, n, *, s, :=, n, 1, -, n, :=, 8, goto, s, print]

 ```
 
Обратите внимание на 8, 25 и goto, которых не было в списке лексем. Это адреса и функция перехода по адресу соотвественно (в данном случае под адресом мы понимаем номер элемента в данном списке). При встрече goto интерпретатор будет продолжать вычисления с номера элемента, который стоит левее goto в этой цепочке. 

### 2. Внутреннее исполнение программы

Теперь иимея список элементов в постфиксной записи исполнять эту программу одно удовольствие! Просто получая какие то элементы мы закладываем их в стек, а если встречаем какой либо оператор то достаем определенное количество элементов. 
Вот пример сложения двух чисел. 

```python
def evaluate(self):
        o1 = self.stack.pop()
        o2 = self.stack.pop()
        res = o1.value + o2.value
        if isinstance(res, int):
            res = PrnInt(res)
        else:
            res = PrnFloat(res)
        self.stack.push(res)
```

В файле Compile.py все реализовано еще и с учетом переменчивости типов данных, например для того чтобы с двумя числами 1.4 типа float и 4 типа int можно было производить арифметические операции. 
Также реализовано возможность вложености условий, это можно заметить в тестах. 

## Тестирование программы

После долгого и мучительного дебага можно приступить к тестированию. У нас будет несколького тестов, представляющих из себя первые программы, которые пишет любой программист. 

### Тест 1

Вывод введеного числа

```python
{
    input(a);
    print(a);
}
```

```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 3
3
```
Отлично первый тест прошел успешно, как мы видим все работает.


### Тест 2   

Программа получает два числа (по одному в каждой строке). Вывести на экран сумму чисел.

```python
{
    input(a);
    input(b);
    print(a + b);
}
```

```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 3
>>> 4
7
```

```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 234.24234
>>> 6345345
6345579.24234
```
Второй тест тоже работает, даже с нецелыми числами. 


### Тест 3

Длина Московской кольцевой автомобильной дороги — 109 километров. Байкер Вася стартует с нулевого километра МКАД и едет со скоростью v километров в час. На какой отметке он остановится через t часов?

В двух строчках вводятся v и t.

```python
{
    input(a);
    input(b);
    print((a * b) % 109);
}
```

```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 38
>>> 9
15
```
Третий тест работает. 


### Тест 4

Вводятся два числа (по одному на каждой строке). Вывести наименьший общий делитель этих чисел.

```python
{
    int temp := 0;
    input(a);
    input(b);
    while (b != 0)
    {
        temp := b;
        b := a % b;
        a := temp;
    }
    print(a);
}
```

```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 884
>>> 153
17
```
```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 2364826487326874.2424242
>>> 28423742.24224234 
3.725290298461914e-09
```
```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 3246726482648723648723642746283764
>>> 4824632848273648732648726424628424
576460752303423488
```
Четвертый тест прошел даже с огромными и дробными числами. 


### Тест 5

Вводится натуральное число N. Вывести факториал N.

```python
{
    input(a);
    int fac := 1;
    if (a == 0)
    {
        print(1);
        &
    }
    else
    {
        while (a > 0)
        {
            fac := fac * a;
            a := a - 1;
        }
    }
    print(fac);
}
```

```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 4
24
```

```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 123
12146304367025331529099877131181532511825408382397052669269085336752145805972232396989773798415332323726739178998923342612698329488403802367592326091522384520570604998598324075751895482385020694083942744064
```
Пятый тест тоже работает, причем сравнительно быстро. 


### Тест 5
Вводится N. Вывести N-ое число Фибоначчи.

```python
{
    int a, b, i, c;
    input(n);
    a := 0;
    b := 1;
    i := 1;
    while (i < n)
    {
        c := a + b;
        a := b;
        b := c;
        i := i + 1;
    }
    print(b);
}
```

```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 3
2
```
```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 123
22698374052006868279099392

```
Пятый тест тоже прошел. 


### Тест 6

Теперь попробуем половить ошибки и посмотреть как на них будет реагировать интерпретатор

```python
{
    input(a)
    input(b);
    print((a * b) % 109);
}
```

```python
С:\Users\PumLang> python pumlang.py main.plg
Invalid syntax error at line 2:  input .
Expected ; but got input
```

```python
{
    iput(a);
    input(b);
    print((a * b) % 109);
}
```

```python
С:\Users\PumLang> python pumlang.py main.plg
Invalid syntax error at line 1:  iput .
Attempt to perform an undeclared variable operation
```

Как мы видим ошибки отлично обрабатываются. 

### Boss fight

Попробуем вывести n-ое простое число

```python
{
    int i, a, j, d, k;
    input(n);
    i := 0
    a := 0;
    j := 2;
    while (j > 0)
    {
        d := 0;
        k := 1;
        while (k < j + 1)
        {
            if (j % k) == 0
            {
                d := d + 1;
            }
            k := k + 1;
        }
        if (d == 2)
        {
            i := i + 1;
            a := j;
        }
        if (j == n)
        {
            j := j - 1;
        }
        else
        {
            j := j + 1;
        }
    }
print(a);
}
```

```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 3
5
```
Это было сложно но оно работает попробуем что нибдуь потяжелее. 
```python
С:\Users\PumLang> python pumlang.py main.plg
>>> 1000000
#five years later
15485863
```
# Заключение

